[{"title":"JAVA 内存结构","date":"2020-01-11T02:15:02.000Z","path":"2020/01/11/JAVA-内存结构/","text":"关于JAVA 内存结构分析1.内存结构的包含哪些内容，如图所示 线程共享区：线程不共享的区域，包含如下区域： ​ 1.方法区 ​ 2.堆 线程独占区：线程不共享的区域，包含如下区域： ​ 1.虚拟机栈 ​ 2.本地方法栈 ​ 3.程序计数器 2.线程独占区（1）程序计数器定义： 一块较小的空间，它可以看作是当前线程所执行的字节码的行号指示器。 运作方式 ： 如果此时线程执行的是JAVA方法，则计数器要记录当前执行的虚拟机字节码指令的地址，如果是native方法，则计数器记录的值为undefined。 作用： JVM的多线程是通过线程轮流切换并分配CPU执行时间片的方式来实现的，任何一个时刻，一个CPU都只会执行一条线程中的指令。为了保证线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程间的程序计数器独立存储，互不影响。（保证线程的运行顺序） 风险（异常）： 没有规定任何OOM（内存溢出）情况的区域，因为是由虚拟机内部维护的。 （2）虚拟机栈定义：每个线程有一个私有的栈，随着线程的创建而创建，生命周期与线程相同 作用： 方法的调用到执行完毕，对应的就是栈帧的入栈和出栈的过程（方法调用即创建栈帧，并把当前栈帧放入虚拟机栈，方法结束即栈帧从虚拟机栈抛出） 风险（异常）： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError（栈溢出） 异常，如下实例： 由于上一个栈帧入栈后，还没出栈时，又调用了一次test()方法，又生成了一个栈帧入栈，导致栈有进无出，直到超出栈的深度，造成tackOverflowError（栈溢出） 异常。 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError（内存溢出） 异常 栈帧：虚拟机栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表、操作数栈、动态链接、方法出口等信息。 局部标量表：是一组变量值的存储空间，用于存放 方法参数 和 局部变量 操作数栈：方法执行算术运算或者是调用其他的方法进行参数传递的时候时的媒介 动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接 方法出口：当一个方法开始执行以后，只有两种方法可以退出当前方法 当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口（Normal Method Invocation Completion），一般来说，调用者的PC计数器可以作为返回地址。（正常执行） 当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口（Abrupt Method Invocation Completion），返回地址要通过异常处理器表来确定。（抛出异常） （3）本地方法栈定义： 和虚拟机栈类似，两者的区别就是虚拟机栈是为虚拟机执行java方法服务，本地方法栈为虚拟机执行native方法服务 。 注意： HotSpot虚拟机不区分虚拟机栈和本地方法栈，两者是一块的。 风险（异常）： 与虚拟机栈一样，本地方法栈也会抛StackOverflowError和OutOfMemoryError异常。 3.线程共享区（1）堆 定义：用于存放对象实例，是垃圾收集器管理的主要区域，也称GC堆，主要采用分代收集垃圾算法回收垃圾 风险（异常）：当堆中没有足够的内存完成对象实例化 &amp; 堆无法再拓展时，会抛OutOfMemoryError异常 分配内存：堆中分配内存的方法有2种： 碰撞指针：通过指针移动到一块新的区域来分配内存，不过这种分配方式需要区域绝对规整连续。 空闲列表：不是规整的内存区域，就是有一个表记录了空闲的内存，然后从表中获取空闲内存的位置信息，分配完后就从表中去除信息。 （2）方法区 定义： 存储了加载的类信息、常量、静态变量等数据，JVM规范中容量可以是固定的也可以是动态收缩的，并且内存不用保证有连续性 风险（异常）： 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 对比： JDK 7之前，使用永久代实现方法区（容易遇到内存溢出问题），JDK 7 使用Native Memory本地内存来代替永久代，JDK8使用Metaspace元数据区来实现方法区，利用元数据分配只受本地内存大小的限制（本地内存剩多少，元数据就有多大）来解决永久代的OOM问题 4.当创建对象是，各部分内存结构的存储作用，如下有一个例子"},{"title":"关于hashMap的面试考点","date":"2019-10-12T02:59:26.000Z","path":"2019/10/12/关于hashMap的面试考点/","text":"关于HashMap的一些面试考点1.数据结构分析答： 在jdk1.7之前，是数组和链表的结合体；外层是数组结构，内层是链表结构。 在jdk1.8之后，是数组和红黑树的结构，当然一开始还是数组-链表的结构，当链表 的长度大于一点阈值时，链表会转换为红黑树，这样可以减少链表的查询时间。 2.非线程安全答： hashMap是线程不安全的，如果要保证线程安全，应该使用hashTable替代。 结果： 若使用多线程操作同一个hashMap，可能导致陷入死循环的结果，造成死锁，CPU使用率100%的问题（基于jdk1.7之前的版本）。 为什么： 贴上测试代码： public class HashMapInfiniteLoop &#123; private static HashMap&lt;Integer,String&gt; map &#x3D; new HashMap&lt;Integer,String&gt;(2，0.75f); public static void main(String[] args) &#123; map.put(5， &quot;C&quot;); new Thread(&quot;Thread1&quot;) &#123; public void run() &#123; map.put(7, &quot;B&quot;); System.out.println(map); &#125;; &#125;.start(); new Thread(&quot;Thread2&quot;) &#123; public void run() &#123; map.put(3, &quot;A); System.out.println(map); &#125;; &#125;.start(); &#125; &#125; 这里需要根据源码来分析一波~~ void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity &#x3D; newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null !&#x3D; e) &#123; Entry&lt;K,V&gt; next &#x3D; e.next; if (rehash) &#123; e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key); &#125; int i &#x3D; indexFor(e.hash, newCapacity); e.next &#x3D; newTable[i]; newTable[i] &#x3D; e; e &#x3D; next; &#125; &#125;&#125; 如上图的374行重点处，是一个遍历桶的操作，有一个指针指向下一个的e=e.next操作，这里就是问题的根源所在。下面来分析如何造成死锁： 我们放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行 然后放开线程2的的断点，让线程2进行resize。结果如下图 注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在Thread2 rehash后，指向了Thread2重组后的链表。 Thread1被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向key(7)，而下一次循环的next = e.next导致了next指向了key(3)。 e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 于是，当我们用线程一调用map.get(11)时，获取map中不存在的元素时，就会一直循坏这个链表，但由于是环形链表，所以是死循环。 3.扩容机制1.什么时候扩容：首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。 当元素数目超过threshold的时候，就要重新扩容。 2.如何扩容：扩容后的HashMap容量是之前容量的两倍，扩容的容量应是2^n（一定是合数）。 3.为什么是按上面这样扩容：HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突（哈希碰撞），HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程 在扩容时，需要把原来的元素重新计算在新的map的位置，本来是一个计算比较复杂的过程，通过上面这样设计，发现原来的元素的 索引 = 原索引 + oldCap，这样就方便计算很多 而且把之前的冲突的节点均匀的分散到新的桶中。 4.Fail-Fast机制答： 采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常"}]