[{"title":"常用Linux基础命令，面试必问","date":"2020-03-29T06:49:24.000Z","path":"2020/03/29/常用Linux基础命令，面试必问/","text":"netstat1.netstat简介​ netstat是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表，实际的网络连接以及每一个网络接口设备的状态信息，netstat用于显示与IP,TCP,UDP和ICMP协议相关的统计数据，一般用于查询本机各端口的网络连接情况。 2.netstat常用参数​ 常用的几个参数有：-a -n -p -l -a 显示所有socket，包括正在监听的 -l 显示有在 Listen (监听) 的服务状态 -n 以网络IP地址代替名称，显示网络连接情形 -p 显示建立相关连接的程序名和PID -t 显示TCP协议的连接情况 -u 显示UDP协议的连接情况 -s 显示每个协议的统计 -b 显示在创建每个连接或监听端口时涉及的可执行程序 -c 每个1秒就重新显示一遍，直到用户中断 3.netstat常用组合命令Proto:连接协议Local Address:本地地址（如果使用参数n,则会以IP形式展示）Foreign Address:外部地址（如果使用参数n,则会以IP形式展示）PID：进程号(可以使用kill -9 pid 杀死相关进程)Program name：程序名State：监听状态 1.LISTEN 监听来自远方的TCP端口的连接请求 2.SYN-SENT 在发送连接请求后等待匹配的连接请求 3.SYN-RECEIVED 在收到和发送一个连接请求后等待对方对连接请求的确认 4.ESTABLISHED 代表一个打开的连接 5.TIME-WAIT 等待足够的时间以确保远程TCP接收到连接中断请求的确认 6.CLOSED 没有任何连接状态 7.CLOSED-WAIT 等待从本地用户发来的连接中断请求 netstat -a （列出所有连接，包括tcp、udp连接） $ netstat -aActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 enlightened:domain *:* LISTEN tcp 0 0 localhost:ipp *:* LISTEN tcp 0 0 enlightened.local:54750 li240-5.members.li:http ESTABLISHEDtcp 0 0 enlightened.local:49980 del01s07-in-f14.1:https ESTABLISHEDtcp6 0 0 ip6-localhost:ipp [::]:* LISTEN udp 0 0 enlightened:domain *:* netstat -ntlp|grep port (查询端口号是否被占用) [root@77-9-162-bx-core ~]# netstat -ntlp|grep 8090Proto Recv-Q Local Address Foreign Address State PID&#x2F;Program nametcp 0 0 0.0.0.0:8090 0.0.0.0:* LISTEN 8904&#x2F;vintage 3.netstat -ntlp|grep 程序名 (查询程序占用的端口) [root@77-9-162-bx-core ~]# netstat -ntlp|grep mysqlProto Recv-Q Local Address Foreign Address State PID&#x2F;Program nametcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 8809&#x2F;mysql ps1.ps简介​ ps(process status) 命令是 Linux 下最常用的进程查看工具，使用该命令可以确定哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等。 注意：ps 命令工具显示的是进程的瞬间状态，并不是动态连续显示，如果想对进程状态进行实时监控应该用 top 命令。2.ps常用参数 参数： ​ -A ：所有的进程均显示出来，与 -e 具有同样的效用； ​ -a ：显示现行终端机下的所有进程，包括其他用户的进程； ​ -e：显示系统内所有进程的信息。与 -A 选项功能相同 ​ -f：使用完整 (full) 的格式显示进程信息，如果只有 ps -e 则输出进程信息的格式和只使用 ps 一样 -u ：以用户为主的进程状态 -x：显示当前用户在所有终端下的进程信息 3.ps常用组合命令*PID：表示该进程的唯一 ID 号TTY 或 TT：启动进程的终端名。表示该进程在哪个终端上运行。不是从终端启动的进程或与终端机无关的进程则显示为 ？ *TIME：该进程使用 CPU 的累计时间*CMD：该进程所运行的命令UID：启动该进程的用户的 ID 号PPID：代表该进程的父进程的 ID 号*STIME&#x2F;START：表示进程的启动时间*USER：启动该进程的用户帐号名称*%CPU：表示进程的 CPU 占用率*%MEM：表示进程的内存占用率VSZ：表示进程虚拟内存的大小，以 KB 为单位 ps -aux（以面向用户的格式显示当前终端下的所有信息） ps -ef|grep port (查询相关端口对应的进程信息) ps -ef|grep 程序名(查询程序名对应的进程信息) ps -aux –sort=%mem （以内存占用率作为升序排序，默认+升序排序，+是升序，-是降序）"},{"title":"JAVA 内存结构","date":"2020-01-11T02:15:02.000Z","path":"2020/01/11/JAVA-内存结构/","text":"关于JAVA 内存结构分析1.内存结构的包含哪些内容，如图所示 线程共享区：线程不共享的区域，包含如下区域： ​ 1.方法区 ​ 2.堆 线程独占区：线程不共享的区域，包含如下区域： ​ 1.虚拟机栈 ​ 2.本地方法栈 ​ 3.程序计数器 2.线程独占区（1）程序计数器定义： 一块较小的空间，它可以看作是当前线程所执行的字节码的行号指示器。 运作方式 ： 如果此时线程执行的是JAVA方法，则计数器要记录当前执行的虚拟机字节码指令的地址，如果是native方法，则计数器记录的值为undefined。 作用： JVM的多线程是通过线程轮流切换并分配CPU执行时间片的方式来实现的，任何一个时刻，一个CPU都只会执行一条线程中的指令。为了保证线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程间的程序计数器独立存储，互不影响。（保证线程的运行顺序） 风险（异常）： 没有规定任何OOM（内存溢出）情况的区域，因为是由虚拟机内部维护的。 （2）虚拟机栈定义：每个线程有一个私有的栈，随着线程的创建而创建，生命周期与线程相同 作用： 方法的调用到执行完毕，对应的就是栈帧的入栈和出栈的过程（方法调用即创建栈帧，并把当前栈帧放入虚拟机栈，方法结束即栈帧从虚拟机栈抛出） 风险（异常）： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError（栈溢出） 异常，如下实例： 由于上一个栈帧入栈后，还没出栈时，又调用了一次test()方法，又生成了一个栈帧入栈，导致栈有进无出，直到超出栈的深度，造成tackOverflowError（栈溢出） 异常。 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError（内存溢出） 异常 栈帧：虚拟机栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表、操作数栈、动态链接、方法出口等信息。 局部标量表：是一组变量值的存储空间，用于存放 方法参数 和 局部变量 操作数栈：方法执行算术运算或者是调用其他的方法进行参数传递的时候时的媒介 动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接 方法出口：当一个方法开始执行以后，只有两种方法可以退出当前方法 当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口（Normal Method Invocation Completion），一般来说，调用者的PC计数器可以作为返回地址。（正常执行） 当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口（Abrupt Method Invocation Completion），返回地址要通过异常处理器表来确定。（抛出异常） （3）本地方法栈定义： 和虚拟机栈类似，两者的区别就是虚拟机栈是为虚拟机执行java方法服务，本地方法栈为虚拟机执行native方法服务 。 注意： HotSpot虚拟机不区分虚拟机栈和本地方法栈，两者是一块的。 风险（异常）： 与虚拟机栈一样，本地方法栈也会抛StackOverflowError和OutOfMemoryError异常。 3.线程共享区（1）堆 定义：用于存放对象实例，是垃圾收集器管理的主要区域，也称GC堆，主要采用分代收集垃圾算法回收垃圾 风险（异常）：当堆中没有足够的内存完成对象实例化 &amp; 堆无法再拓展时，会抛OutOfMemoryError异常 分配内存：堆中分配内存的方法有2种： 碰撞指针：通过指针移动到一块新的区域来分配内存，不过这种分配方式需要区域绝对规整连续。 空闲列表：不是规整的内存区域，就是有一个表记录了空闲的内存，然后从表中获取空闲内存的位置信息，分配完后就从表中去除信息。 （2）方法区 定义： 存储了加载的类信息、常量、静态变量等数据，JVM规范中容量可以是固定的也可以是动态收缩的，并且内存不用保证有连续性 风险（异常）： 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 对比： JDK 7之前，使用永久代实现方法区（容易遇到内存溢出问题），JDK 7 使用Native Memory本地内存来代替永久代，JDK8使用Metaspace元数据区来实现方法区，利用元数据分配只受本地内存大小的限制（本地内存剩多少，元数据就有多大）来解决永久代的OOM问题 4.当创建对象是，各部分内存结构的存储作用，如下有一个例子"},{"title":"关于hashMap的面试考点","date":"2019-10-12T02:59:26.000Z","path":"2019/10/12/关于hashMap的面试考点/","text":"关于HashMap的一些面试考点1.数据结构分析答： 在jdk1.7之前，是数组和链表的结合体；外层是数组结构，内层是链表结构。 在jdk1.8之后，是数组和红黑树的结构，当然一开始还是数组-链表的结构，当链表 的长度大于一点阈值时，链表会转换为红黑树，这样可以减少链表的查询时间。 2.非线程安全答： hashMap是线程不安全的，如果要保证线程安全，应该使用hashTable替代。 结果： 若使用多线程操作同一个hashMap，可能导致陷入死循环的结果，造成死锁，CPU使用率100%的问题（基于jdk1.7之前的版本）。 为什么： 贴上测试代码： public class HashMapInfiniteLoop &#123; private static HashMap&lt;Integer,String&gt; map &#x3D; new HashMap&lt;Integer,String&gt;(2，0.75f); public static void main(String[] args) &#123; map.put(5， &quot;C&quot;); new Thread(&quot;Thread1&quot;) &#123; public void run() &#123; map.put(7, &quot;B&quot;); System.out.println(map); &#125;; &#125;.start(); new Thread(&quot;Thread2&quot;) &#123; public void run() &#123; map.put(3, &quot;A); System.out.println(map); &#125;; &#125;.start(); &#125; &#125; 这里需要根据源码来分析一波~~ void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity &#x3D; newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null !&#x3D; e) &#123; Entry&lt;K,V&gt; next &#x3D; e.next; if (rehash) &#123; e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key); &#125; int i &#x3D; indexFor(e.hash, newCapacity); e.next &#x3D; newTable[i]; newTable[i] &#x3D; e; e &#x3D; next; &#125; &#125;&#125; 如上图的374行重点处，是一个遍历桶的操作，有一个指针指向下一个的e=e.next操作，这里就是问题的根源所在。下面来分析如何造成死锁： 我们放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行 然后放开线程2的的断点，让线程2进行resize。结果如下图 注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在Thread2 rehash后，指向了Thread2重组后的链表。 Thread1被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向key(7)，而下一次循环的next = e.next导致了next指向了key(3)。 e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 于是，当我们用线程一调用map.get(11)时，获取map中不存在的元素时，就会一直循坏这个链表，但由于是环形链表，所以是死循环。 3.扩容机制1.什么时候扩容：首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。 当元素数目超过threshold的时候，就要重新扩容。 2.如何扩容：扩容后的HashMap容量是之前容量的两倍，扩容的容量应是2^n（一定是合数）。 3.为什么是按上面这样扩容：HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突（哈希碰撞），HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程 在扩容时，需要把原来的元素重新计算在新的map的位置，本来是一个计算比较复杂的过程，通过上面这样设计，发现原来的元素的 索引 = 原索引 + oldCap，这样就方便计算很多 而且把之前的冲突的节点均匀的分散到新的桶中。 4.Fail-Fast机制答： 采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常"}]